<!DOCTYPE html>
<html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <title>Jie&#039;s Blog</title> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <link href="http://127.0.0.1:8000/blog/css/bootstrap.min.css" rel="stylesheet" media="screen"> <link href="http://127.0.0.1:8000/blog/css/custom.css" rel="stylesheet" media="screen"> <link rel="alternate" href="http://127.0.0.1:8000/blog/rss.xml" type="application/rss+xml" /> <script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'jie']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script> </head> <body> <div class="container-fluid"> <div class="row-fluid"> <div class="offset2 span8"> <div class="row-fluid"> <div class="navbar navbar-inverse"> <div class="navbar-inner"> <a class="brand" href="http://127.0.0.1:8000/blog">Jie&#039;s Blog</a> <ul class="nav"> <li><a href="http://127.0.0.1:8000">Home</a></li> </ul> </div> </div> </div> <div class="row-fluid"> <h1 class="page-header">Content tagged mindmap</h1> <div class="row-fluid"> <h1><a href="http://127.0.0.1:8000/blog/posts/Metaprogrammingcode-generator.html">Metaprogramming(code generator)</a></h1> <p class="date-posted">posted on 2014-05-03 19:23:53</p> <p>根本没有什么元编程，只有编程！？
<br>
<img src="/static/img/CodeWriter.png" alt="" />
<br></p>

<ul>
<li><p>注1: 由于代码字符串和块非常相似，因此，在很多情况下，可以选择使用任
  意一种。但是，一般情况下，只要能用块就尽量用块。</p></li>
<li><p>注2: 使一个模块可以通过钩子方法扩展它的包含者。</p></li>
</ul>

<pre><code>module M
  def self.included(base)
    base.extend(ClassMethods)
  end

  module ClassMethods
    def my_method
      'a class method'
    end
  end
end

class C
  include M
end

C.my_method   # =>  "a class method"</code></pre>
 </div><div class="row-fluid"> <h1><a href="http://127.0.0.1:8000/blog/posts/Meta-programmingClass.html">Meta programming(Class)</a></h1> <p class="date-posted">posted on 2014-05-03 17:51:04</p> <p>在Ruby中，使用class定义类时，实际上是在运行代码，这与java之类的静态语
言有很大的差别。<br/>
另外，类只是一个增强的模块，因此，任何适用于类的东西也
适用于模块。
<br>
<img src="/static/img/ObjectDefinitions.png" alt="Object Definitions" />
<br>
 * 注1:在类(或模块)定义时，类本身充当了当前对象self的角色。</p>

<pre><code>result = class MyClass
  self
end

result     # =>  MyClass</code></pre>

<ul>
<li><p>注2:Ruby中总是存在一个当前对象self，与此类似，也总是存在一个当前类
   （或模块）。每当通过class关键字来打开一个类时，这个类就成为当前类，
   但是使用class关键字需要一个类的名字。
   如果只有一个类的引用，需要用class_eval()方法打开这个类。</p></li>
<li><p>注3：类实例变量仅仅是属于Class类对象的普通实例变量。它仅仅可以被类
   本身所访问，而不能被类的实例或之类所访问。</p></li>
<li><p>注4：类方法的实质，它们只是一个类的单件方法。</p></li>
<li><p>注5: 在类定义中使用一个类方法。</p></li>
<li><p>注6: eigenclass是一个对象特有的隐藏类，它是单件方法存在的地方。Ruby中可以使用如下语法进入eigenclass的作用域。</p></li>
</ul>

<pre><code>class << an_object 
  # do something
end</code></pre>

<ul>
<li><p>注7: 如果对象是eigenclass，那么Ruby不是从它所在的类开始，而是从这个
   eigenclass类中开始查找方法，如图。
   <br>
   <img src="/static/img/eigenclassMethod.png" alt="Eigenclass" /></p></li>
<li><p>注8: 一个对象的eigenclass的超类是这个对象的类，一个类的eigenclass的
   超类是这个类的超类的eigenclass,如图。
   <img src="/static/img/eigenclassInherit.png" alt="" /></p></li>
<li><p>注9: 通过向类的eigenclass中混入模块来定义类方法。</p></li>
<li><p>注10: 通过给一个对象的eigenclass混入模块来定义单件方法。</p></li>
<li><p>注11: 1. 给方法定义一个别名；2.重新定义这个方法；3.在新的方法中调用老的方法。</p></li>
<li><p>注12: 1.环绕别名是一种猴子补丁，可能会破坏已有代码。2.你永远不该把一个环绕别名加载两次。</p></li>
</ul>
 </div><div class="row-fluid"> <h1><a href="http://127.0.0.1:8000/blog/posts/MetaprogrammingBlock.html">Metaprogramming(Block)</a></h1> <p class="date-posted">posted on 2014-05-03 17:06:28</p> <p>块继承自“函数式编程语言(functional programming languages)”的世界。
<br>
<img src="/static/img/blocks.png" alt="" />
<br>
* 注1: 在一个方法中，可以向Ruby询问当前的方法调用是否包含块。这可以通
  过Kernel#block_given?()方法来做到。</p>

<ul>
<li><p>注2: 如果在一个扁平作用域中定义了多个方法，这这些方法可以用一个作用
  域们进行保护，并共享绑定，这种技术称为共享作用域。</p></li>
<li><p>注3: 传递给instance_eval()方法的块称为一个上下文探针，因为它就像是一
  个深入到对象中的代码片段，对其操作。</p></li>
</ul>

<pre><code>class C
  def initialize
    @x="a private instance variable"
  end
end

obj=C.new
obj.instance_eval(@x) #=>"a private instance variable"</code></pre>

<ul>
<li>注4: 有时，你会创建一个对象，仅仅是为了在其中执行块。这样的对象称为洁净室。洁净室仅仅是一个用来执行块的环境，它通常还会暴露若干有用的方法供块调用。</li>
</ul>

<pre><code>class CleanRoom
  def a_useful_method(x);x*2;end
end

CleanRoom.new.instance_eval{a_useful_method(3)}  #=>6</code></pre>

<ul>
<li><p>注5: 1.return方式不同。lambda从可调用对象中返回，而proc从原始上下文中返回。
2.参数检查方式不同。如果lambda的产生数量不对，这它会失败，同时抛出一个
ArgumentError错误；而proc则会自动调整传递进来的参数，通过忽略多余的参
数以及为未赋值参数置nil。</p></li>
<li><p>注6: Method对象类似于lambda，但是有一个重要的区别：lambda在它的作用域中执行(它是一个闭包)，而Method对象会在它自身所在对象的作用域中执行。</p></li>
</ul>
 </div><div class="row-fluid"> <h1><a href="http://127.0.0.1:8000/blog/posts/MetaprogrammingMethods.html">Metaprogramming(Methods)</a></h1> <p class="date-posted">posted on 2014-05-03 16:44:19</p> <p>Ruby是动态语言，没有静态类型检查，同时也提供了很多java等静态语言无法提
供的编程技巧。本章主要专注于消除重复代码的技巧，通过用两种不同的方式对一
段代码的重构来展示Ruby的强大功能，涉及的知识点比较少。
<br>
<img src="/static/img/methods.png" alt="" />
<br>
* 注1: method_missing()是Kernel中的一个实例方法，当Ruby找不到调用的方
  法时，它最后就会调用这个名为method_missing()的方法。</p>

<ul>
<li>注2: 移除一个对象中的所有方法，以便把它们转换成幽灵方法。</li>
</ul>

<hr/>

<p><strong>重构例子</strong></p>

<pre><code># 原始代码
class Computer
  def initialize(computer_id, data_source)
    @id = computer_id
    @data_source = data_source
  end
  def mouse
    info = @data_source.get_mouse_info(@id)
    price = @data_source.get_mouse_price(@id)
    result = "Mouse: #{info} ($#{price})"
    return "* #{result}" if price >= 100
    result
  end
  def cpu
    info = @data_source.get_cpu_info(@id)
    price = @data_source.get_cpu_price(@id)
    result = "Cpu: #{info} ($#{price})"
    return "* #{result}" if price >= 100
    result
  end
  def keyboard
    info = @data_source.get_keyboard_info(@id)
    price = @data_source.get_keyboard_price(@id)
    result = "Keyboard: #{info} ($#{price})"
    return "* #{result}" if price >= 100
    result
  end
  # ...
end</code></pre>

<pre><code># 使用动态方法重构
class Computer
  def initialize(computer_id, data_source)
    @id = computer_id
    @data_source = data_source
    # 使用内省方式提取所有组件的名字
    data_source.methods.grep(/^get_(.*)_info$/) { Computer.define_component $1 }
  end

  def self.define_component(name)
    # 使用define_method()动态定义方法
    define_method(name) do
      # 使用send()方法集中处理
      info = @data_source.send "get_#{name}_info", @id
      price = @data_source.send "get_#{name}_price", @id
      result = "#{name.capitalize}: #{info} ($#{price})"
      return "* #{result}" if price >= 100
      result
    end
  end
  
  define_component :mouse
  define_component :cpu
  define_component :keyboard
end</code></pre>

<pre><code># 使用幽灵方法重构
class Computer
  # 创建白板， 以免方法命名冲突
  instance_methods.each do |m|
    undef_method m unless m.to_s =~ /^__|method_missing|respond_to?/
  end

  def initialize(computer_id, data_source)
    @id = computer_id
    @data_source = data_source
  end

  # 在method_missing()中创建方法
  def method_missing(name, *args)
    super if !respond_to?(name)
    info = @data_source.send("get_#{name}_info", @id)
    price = @data_source.send("get_#{name}_price", @id)
    result = "#{name.to_s.capitalize}: #{info} ($#{price})"
    return "* #{result}" if price >= 100
    result
  end

  # 覆写respond_to?()，保证查询方法时返回正确结果
  def respond_to?(method)
    @data_source.respond_to?("get_#{method}_info") || super
  end
end</code></pre>
 </div><div class="row-fluid"> <h1><a href="http://127.0.0.1:8000/blog/posts/MetaprogrammingObjectModel.html">Metaprogramming(ObjectModel)</a></h1> <p class="date-posted">posted on 2014-05-02 20:44:57</p> <p>在Ruby程序中，除了对象之外，还有类、模块以及实例变量这些语言构件。这
些语言构件存在于其中的系统称为<strong>对象模型</strong>。在对象模型中，你可以找到诸
如&quot;这个方法来自哪个类&quot;和&quot;当我包含这个模块是会发生什么&quot;此类问题的答案。
<br>
<img src="/static/img/ObjectModel.png" alt="" />
<br>
* 注1: class关键字更像是一个作用域操作符而不是类型声明语句，它的确可以
  创建一个还不存在的类，不过也可以把这看成是一个副作用。对于class关键
  字，其核心任务是把你带到类的上下文中，让你可以在其中定义方法。</p>

<ul>
<li><p>注2: 修改已有类的特性时，由于粗心导致bug，像这种鲁莽的修改方式被称为
  猴子补丁。不过，如果是正确的运行打开类这种技术，猴子补丁也可以表示为
  一个褒义词，会很有用。</p></li>
<li><p>注3: 对象是一组实例变量外加一个指向其类的引用。对象的方法并不存在于对象本身，而是存在于对象的类中。在类中，这些方法被称为类的实例方法。
类是一个对象（Class类的一个实例）外加一组实例方法和一个对其超类的引用。
值得注意的是，实例变量存放在对象中，而方法存放在类中，比如</p></li>
</ul>

<pre><code>class MyClass
  def my_method
    @v = 1
  end
end

obj = MyClass.new
obj.class              # => MyClass</code></pre>

<p>上面代码结构可表示为：
<img src="/static/img/ObjectClass.png" alt="" /></p>

<ul>
<li><p>注4: 一个类只不过是一个增强的Module，它只是在Module基础上增加了三个
  方法——new()、allocate()和superclass()而已，结构如下。
  <img src="/static/img/ModuleClass.png" alt="" /></p></li>
<li><p>注5: 每个类都有一个祖先链，这个链从自己所属的类开始，向上直到BasicObject结束。其中，Object类包含了Kernel模块，故Kernel方法对所有对象可用。</p></li>
</ul>
 </div><div class="row-fluid"> <h1><a href="http://127.0.0.1:8000/blog/posts/MetaprogrammingTutorial.html">Metaprogramming(Tutorial)</a></h1> <p class="date-posted">posted on 2014-04-29 21:56:38</p> <p>元编程(Metaprogramming)，简单来说，就是写出编写代码的代码。正式的定义为：编写在运行时操纵语言构件的代码。
Ruby是一门对元编程支持很强大的语言(只是比lisp弱一点)，而且，元编程
也是通向Ruby的高级编程之路。可以说，除非掌握了元编程否则不能算是真正掌
握了Ruby。
下图简要总结了&lt;Ruby元编程&gt;的基本内容，经验有限，不足之处请多指正。
<br>
<img src="/static/img/RubyMetaprogramming.png" alt="" />
<br> 
就如蜘蛛侠大叔曾经说的，能力越大，责任越大。元编程赋予了你强大的能力，同时也意味着你需要肩负更大的责任。</p>
 </div> <div id="relative-nav"> <ul class="pager">   </ul> </div> <div class="row-fluid"> <p>This blog covers <a href="http://127.0.0.1:8000/blog/tag/website.html">website</a>, <a href="http://127.0.0.1:8000/blog/tag/visualize.html">visualize</a>, <a href="http://127.0.0.1:8000/blog/tag/vim.html">vim</a>, <a href="http://127.0.0.1:8000/blog/tag/tools.html">tools</a>, <a href="http://127.0.0.1:8000/blog/tag/ruby.html">ruby</a>, <a href="http://127.0.0.1:8000/blog/tag/rails.html">rails</a>, <a href="http://127.0.0.1:8000/blog/tag/python.html">python</a>, <a href="http://127.0.0.1:8000/blog/tag/mindmap.html">mindmap</a>, <a href="http://127.0.0.1:8000/blog/tag/learning.html">learning</a>, <a href="http://127.0.0.1:8000/blog/tag/javascript.html">javascript</a>, <a href="http://127.0.0.1:8000/blog/tag/emacs.html">emacs</a>, <a href="http://127.0.0.1:8000/blog/tag/clojure.html">clojure</a>, <a href="http://127.0.0.1:8000/blog/tag/algorithm.html">algorithm</a>, <a href="http://127.0.0.1:8000/blog/tag/a.html">a*</a> </p> </div> <div class="row-fluid"> <p>View content from <a href="http://127.0.0.1:8000/blog/date/2014-03.html">2014-03</a>, <a href="http://127.0.0.1:8000/blog/date/2014-04.html">2014-04</a>, <a href="http://127.0.0.1:8000/blog/date/2014-05.html">2014-05</a> </p> </div> </div>  <div class="row-fluid"> <hr> <p class="fineprint">Unless otherwise credited all material <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/deed.en_US"> <img alt="Creative Commons License" style="border-width:0" src="http://127.0.0.1:8000/blog/img/cc-by-sa.png" /> </a> by Jie <a id="coleslaw-logo" href="https://github.com/redline6561/coleslaw"> <img src="http://127.0.0.1:8000/blog/img/logo_small.jpg" alt="Coleslaw logo" /></p> </a> </div> </div> </div> </div> <script src="http://127.0.0.1:8000/blog/js/bootstrap.min.js"></script> </body> </html>