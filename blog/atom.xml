<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom"> <title>Jie&#039;s Blog</title> <link href="http://127.0.0.1:8000/blog"/> <link type="application/atom+xml" rel="self" href="http://127.0.0.1:8000/blog/atom.xml"/> <updated>Wed, 04 Feb 2015 22:46:04 +0800</updated> <author> <name>Jie</name> </author> <entry> <link type="text/html" rel="alternate" href="http://127.0.0.1:8000/blog/posts/VIM-for-Rails.html"/> <title>VIM for Rails</title> <published>2014-05-27 01:35:30</published> <updated>2014-05-27 01:35:30</updated> <author> <name>Jie</name> <uri>http://127.0.0.1:8000/blog</uri> </author> <content type="html">&lt;p&gt;使用vim来进行Rails开发，对配置过程略做记录，前提vim已安装完毕。&lt;br/&gt;
1、 &lt;strong&gt;安装pathogen&lt;/strong&gt;&lt;br/&gt;
pathogens是vim的插件管理工具，可简化对vim插件的管理。&lt;br/&gt;
安装如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir -p ~/.vim/autoload ~/.vim/bundle; \
curl -LSso ~/.vim/autoload/pathogen.vim \
    https://raw.github.com/tpope/vim-pathogen/master/autoload/pathogen.vim;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在&lt;code&gt;.vimrc&lt;/code&gt;中加入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;execute pathogen#infect()
&quot; 加在下列配置之前
syntax on
filetype plugin indent on&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2、 &lt;strong&gt;rails.vim&lt;/strong&gt;&lt;br/&gt;
rails插件，无需多介绍。&lt;br/&gt;
常用快捷键:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gf           =&gt;  跳转到定义
ctrl+6       =&gt;  返回上一文件
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
# 查找文件
:Rfind routes.rb

# 打开model
:Rmodel user

# 打开controller
:Rcontroller users
:Rcont users

# 打开view
:Rview user/index
:Rview user/_user

# 启动server
:Rserver
# 关闭server
:Rserver! -

# 打开js文件
:Rjavascript js_name&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;:其&lt;code&gt;Rtag&lt;/code&gt;命令使用的是&lt;code&gt;exuberant-ctags&lt;/code&gt;中的&lt;code&gt;ctags&lt;/code&gt;，安装Emacs后也会安装一个&lt;code&gt;ctag&lt;/code&gt;工具，会与之冲突，可以将Emacs的&lt;code&gt;ctags&lt;/code&gt;重命名后安装&lt;code&gt;exuberant-ctags&lt;/code&gt;解决之。&lt;/p&gt;

&lt;p&gt;3、 &lt;strong&gt;nerdtree&lt;/strong&gt;&lt;br/&gt;
显示目录树，命令&lt;code&gt;:NERDTree&lt;/code&gt;显示目录。   &lt;/p&gt;

&lt;p&gt;4、 &lt;strong&gt;vim-surround&lt;/strong&gt;&lt;br/&gt;
方便输入括号等的插件，使用&lt;code&gt;ctrl+g s =&lt;/code&gt;，即可插入&lt;code&gt;&amp;lt;%=  %&amp;gt;&lt;/code&gt;。   &lt;/p&gt;

&lt;p&gt;5、 &lt;strong&gt;sparkup&lt;/strong&gt;&lt;br/&gt;
html编写插件，输入&lt;code&gt;div#header&lt;/code&gt;，然后按&lt;code&gt;ctrl+e&lt;/code&gt;，就会扩展为
&lt;code&gt;&amp;lt;div id=&amp;quot;header&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;6、 &lt;strong&gt;snipmate&lt;/strong&gt;&lt;br/&gt;
代码片段补全&lt;/p&gt;

&lt;p&gt;7、 &lt;strong&gt;neocomplcache&lt;/strong&gt;&lt;br/&gt;
代码补全提示&lt;/p&gt;

&lt;p&gt;8、 &lt;strong&gt;auto-pairs&lt;/strong&gt;&lt;br/&gt;
括号自动补全&lt;/p&gt;
</content> </entry><entry> <link type="text/html" rel="alternate" href="http://127.0.0.1:8000/blog/posts/Metaprogrammingcode-generator.html"/> <title>Metaprogramming(code generator)</title> <published>2014-05-03 19:23:53</published> <updated>2014-05-03 19:23:53</updated> <author> <name>Jie</name> <uri>http://127.0.0.1:8000/blog</uri> </author> <content type="html">&lt;p&gt;根本没有什么元编程，只有编程！？
&lt;br&gt;
&lt;img src=&quot;/static/img/CodeWriter.png&quot; alt=&quot;&quot; /&gt;
&lt;br&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;注1: 由于代码字符串和块非常相似，因此，在很多情况下，可以选择使用任
  意一种。但是，一般情况下，只要能用块就尽量用块。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;注2: 使一个模块可以通过钩子方法扩展它的包含者。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;module M
  def self.included(base)
    base.extend(ClassMethods)
  end

  module ClassMethods
    def my_method
      &#039;a class method&#039;
    end
  end
end

class C
  include M
end

C.my_method   # =&gt;  &quot;a class method&quot;&lt;/code&gt;&lt;/pre&gt;
</content> </entry><entry> <link type="text/html" rel="alternate" href="http://127.0.0.1:8000/blog/posts/Meta-programmingClass.html"/> <title>Meta programming(Class)</title> <published>2014-05-03 17:51:04</published> <updated>2014-05-03 17:51:04</updated> <author> <name>Jie</name> <uri>http://127.0.0.1:8000/blog</uri> </author> <content type="html">&lt;p&gt;在Ruby中，使用class定义类时，实际上是在运行代码，这与java之类的静态语
言有很大的差别。&lt;br/&gt;
另外，类只是一个增强的模块，因此，任何适用于类的东西也
适用于模块。
&lt;br&gt;
&lt;img src=&quot;/static/img/ObjectDefinitions.png&quot; alt=&quot;Object Definitions&quot; /&gt;
&lt;br&gt;
 * 注1:在类(或模块)定义时，类本身充当了当前对象self的角色。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;result = class MyClass
  self
end

result     # =&gt;  MyClass&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;注2:Ruby中总是存在一个当前对象self，与此类似，也总是存在一个当前类
   （或模块）。每当通过class关键字来打开一个类时，这个类就成为当前类，
   但是使用class关键字需要一个类的名字。
   如果只有一个类的引用，需要用class_eval()方法打开这个类。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;注3：类实例变量仅仅是属于Class类对象的普通实例变量。它仅仅可以被类
   本身所访问，而不能被类的实例或之类所访问。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;注4：类方法的实质，它们只是一个类的单件方法。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;注5: 在类定义中使用一个类方法。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;注6: eigenclass是一个对象特有的隐藏类，它是单件方法存在的地方。Ruby中可以使用如下语法进入eigenclass的作用域。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;class &lt;&lt; an_object 
  # do something
end&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;注7: 如果对象是eigenclass，那么Ruby不是从它所在的类开始，而是从这个
   eigenclass类中开始查找方法，如图。
   &lt;br&gt;
   &lt;img src=&quot;/static/img/eigenclassMethod.png&quot; alt=&quot;Eigenclass&quot; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;注8: 一个对象的eigenclass的超类是这个对象的类，一个类的eigenclass的
   超类是这个类的超类的eigenclass,如图。
   &lt;img src=&quot;/static/img/eigenclassInherit.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;注9: 通过向类的eigenclass中混入模块来定义类方法。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;注10: 通过给一个对象的eigenclass混入模块来定义单件方法。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;注11: 1. 给方法定义一个别名；2.重新定义这个方法；3.在新的方法中调用老的方法。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;注12: 1.环绕别名是一种猴子补丁，可能会破坏已有代码。2.你永远不该把一个环绕别名加载两次。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</content> </entry><entry> <link type="text/html" rel="alternate" href="http://127.0.0.1:8000/blog/posts/MetaprogrammingBlock.html"/> <title>Metaprogramming(Block)</title> <published>2014-05-03 17:06:28</published> <updated>2014-05-03 17:06:28</updated> <author> <name>Jie</name> <uri>http://127.0.0.1:8000/blog</uri> </author> <content type="html">&lt;p&gt;块继承自“函数式编程语言(functional programming languages)”的世界。
&lt;br&gt;
&lt;img src=&quot;/static/img/blocks.png&quot; alt=&quot;&quot; /&gt;
&lt;br&gt;
* 注1: 在一个方法中，可以向Ruby询问当前的方法调用是否包含块。这可以通
  过Kernel#block_given?()方法来做到。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;注2: 如果在一个扁平作用域中定义了多个方法，这这些方法可以用一个作用
  域们进行保护，并共享绑定，这种技术称为共享作用域。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;注3: 传递给instance_eval()方法的块称为一个上下文探针，因为它就像是一
  个深入到对象中的代码片段，对其操作。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;class C
  def initialize
    @x=&quot;a private instance variable&quot;
  end
end

obj=C.new
obj.instance_eval(@x) #=&gt;&quot;a private instance variable&quot;&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;注4: 有时，你会创建一个对象，仅仅是为了在其中执行块。这样的对象称为洁净室。洁净室仅仅是一个用来执行块的环境，它通常还会暴露若干有用的方法供块调用。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;class CleanRoom
  def a_useful_method(x);x*2;end
end

CleanRoom.new.instance_eval{a_useful_method(3)}  #=&gt;6&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;注5: 1.return方式不同。lambda从可调用对象中返回，而proc从原始上下文中返回。
2.参数检查方式不同。如果lambda的产生数量不对，这它会失败，同时抛出一个
ArgumentError错误；而proc则会自动调整传递进来的参数，通过忽略多余的参
数以及为未赋值参数置nil。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;注6: Method对象类似于lambda，但是有一个重要的区别：lambda在它的作用域中执行(它是一个闭包)，而Method对象会在它自身所在对象的作用域中执行。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</content> </entry><entry> <link type="text/html" rel="alternate" href="http://127.0.0.1:8000/blog/posts/MetaprogrammingMethods.html"/> <title>Metaprogramming(Methods)</title> <published>2014-05-03 16:44:19</published> <updated>2014-05-03 16:44:19</updated> <author> <name>Jie</name> <uri>http://127.0.0.1:8000/blog</uri> </author> <content type="html">&lt;p&gt;Ruby是动态语言，没有静态类型检查，同时也提供了很多java等静态语言无法提
供的编程技巧。本章主要专注于消除重复代码的技巧，通过用两种不同的方式对一
段代码的重构来展示Ruby的强大功能，涉及的知识点比较少。
&lt;br&gt;
&lt;img src=&quot;/static/img/methods.png&quot; alt=&quot;&quot; /&gt;
&lt;br&gt;
* 注1: method_missing()是Kernel中的一个实例方法，当Ruby找不到调用的方
  法时，它最后就会调用这个名为method_missing()的方法。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;注2: 移除一个对象中的所有方法，以便把它们转换成幽灵方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr/&gt;

&lt;p&gt;&lt;strong&gt;重构例子&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 原始代码
class Computer
  def initialize(computer_id, data_source)
    @id = computer_id
    @data_source = data_source
  end
  def mouse
    info = @data_source.get_mouse_info(@id)
    price = @data_source.get_mouse_price(@id)
    result = &quot;Mouse: #{info} ($#{price})&quot;
    return &quot;* #{result}&quot; if price &gt;= 100
    result
  end
  def cpu
    info = @data_source.get_cpu_info(@id)
    price = @data_source.get_cpu_price(@id)
    result = &quot;Cpu: #{info} ($#{price})&quot;
    return &quot;* #{result}&quot; if price &gt;= 100
    result
  end
  def keyboard
    info = @data_source.get_keyboard_info(@id)
    price = @data_source.get_keyboard_price(@id)
    result = &quot;Keyboard: #{info} ($#{price})&quot;
    return &quot;* #{result}&quot; if price &gt;= 100
    result
  end
  # ...
end&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# 使用动态方法重构
class Computer
  def initialize(computer_id, data_source)
    @id = computer_id
    @data_source = data_source
    # 使用内省方式提取所有组件的名字
    data_source.methods.grep(/^get_(.*)_info$/) { Computer.define_component $1 }
  end

  def self.define_component(name)
    # 使用define_method()动态定义方法
    define_method(name) do
      # 使用send()方法集中处理
      info = @data_source.send &quot;get_#{name}_info&quot;, @id
      price = @data_source.send &quot;get_#{name}_price&quot;, @id
      result = &quot;#{name.capitalize}: #{info} ($#{price})&quot;
      return &quot;* #{result}&quot; if price &gt;= 100
      result
    end
  end
  
  define_component :mouse
  define_component :cpu
  define_component :keyboard
end&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# 使用幽灵方法重构
class Computer
  # 创建白板， 以免方法命名冲突
  instance_methods.each do |m|
    undef_method m unless m.to_s =~ /^__|method_missing|respond_to?/
  end

  def initialize(computer_id, data_source)
    @id = computer_id
    @data_source = data_source
  end

  # 在method_missing()中创建方法
  def method_missing(name, *args)
    super if !respond_to?(name)
    info = @data_source.send(&quot;get_#{name}_info&quot;, @id)
    price = @data_source.send(&quot;get_#{name}_price&quot;, @id)
    result = &quot;#{name.to_s.capitalize}: #{info} ($#{price})&quot;
    return &quot;* #{result}&quot; if price &gt;= 100
    result
  end

  # 覆写respond_to?()，保证查询方法时返回正确结果
  def respond_to?(method)
    @data_source.respond_to?(&quot;get_#{method}_info&quot;) || super
  end
end&lt;/code&gt;&lt;/pre&gt;
</content> </entry><entry> <link type="text/html" rel="alternate" href="http://127.0.0.1:8000/blog/posts/MetaprogrammingObjectModel.html"/> <title>Metaprogramming(ObjectModel)</title> <published>2014-05-02 20:44:57</published> <updated>2014-05-02 20:44:57</updated> <author> <name>Jie</name> <uri>http://127.0.0.1:8000/blog</uri> </author> <content type="html">&lt;p&gt;在Ruby程序中，除了对象之外，还有类、模块以及实例变量这些语言构件。这
些语言构件存在于其中的系统称为&lt;strong&gt;对象模型&lt;/strong&gt;。在对象模型中，你可以找到诸
如&amp;quot;这个方法来自哪个类&amp;quot;和&amp;quot;当我包含这个模块是会发生什么&amp;quot;此类问题的答案。
&lt;br&gt;
&lt;img src=&quot;/static/img/ObjectModel.png&quot; alt=&quot;&quot; /&gt;
&lt;br&gt;
* 注1: class关键字更像是一个作用域操作符而不是类型声明语句，它的确可以
  创建一个还不存在的类，不过也可以把这看成是一个副作用。对于class关键
  字，其核心任务是把你带到类的上下文中，让你可以在其中定义方法。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;注2: 修改已有类的特性时，由于粗心导致bug，像这种鲁莽的修改方式被称为
  猴子补丁。不过，如果是正确的运行打开类这种技术，猴子补丁也可以表示为
  一个褒义词，会很有用。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;注3: 对象是一组实例变量外加一个指向其类的引用。对象的方法并不存在于对象本身，而是存在于对象的类中。在类中，这些方法被称为类的实例方法。
类是一个对象（Class类的一个实例）外加一组实例方法和一个对其超类的引用。
值得注意的是，实例变量存放在对象中，而方法存放在类中，比如&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;class MyClass
  def my_method
    @v = 1
  end
end

obj = MyClass.new
obj.class              # =&gt; MyClass&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码结构可表示为：
&lt;img src=&quot;/static/img/ObjectClass.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;注4: 一个类只不过是一个增强的Module，它只是在Module基础上增加了三个
  方法——new()、allocate()和superclass()而已，结构如下。
  &lt;img src=&quot;/static/img/ModuleClass.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;注5: 每个类都有一个祖先链，这个链从自己所属的类开始，向上直到BasicObject结束。其中，Object类包含了Kernel模块，故Kernel方法对所有对象可用。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</content> </entry><entry> <link type="text/html" rel="alternate" href="http://127.0.0.1:8000/blog/posts/MetaprogrammingTutorial.html"/> <title>Metaprogramming(Tutorial)</title> <published>2014-04-29 21:56:38</published> <updated>2014-04-29 21:56:38</updated> <author> <name>Jie</name> <uri>http://127.0.0.1:8000/blog</uri> </author> <content type="html">&lt;p&gt;元编程(Metaprogramming)，简单来说，就是写出编写代码的代码。正式的定义为：编写在运行时操纵语言构件的代码。
Ruby是一门对元编程支持很强大的语言(只是比lisp弱一点)，而且，元编程
也是通向Ruby的高级编程之路。可以说，除非掌握了元编程否则不能算是真正掌
握了Ruby。
下图简要总结了&amp;lt;Ruby元编程&amp;gt;的基本内容，经验有限，不足之处请多指正。
&lt;br&gt;
&lt;img src=&quot;/static/img/RubyMetaprogramming.png&quot; alt=&quot;&quot; /&gt;
&lt;br&gt; 
就如蜘蛛侠大叔曾经说的，能力越大，责任越大。元编程赋予了你强大的能力，同时也意味着你需要肩负更大的责任。&lt;/p&gt;
</content> </entry><entry> <link type="text/html" rel="alternate" href="http://127.0.0.1:8000/blog/posts/A-Algorithm.html"/> <title>A* Algorithm</title> <published>2014-04-22 18:10:18</published> <updated>2014-04-22 18:10:18</updated> <author> <name>Jie</name> <uri>http://127.0.0.1:8000/blog</uri> </author> <content type="html">&lt;p&gt;A*算法是一种经典的启发式搜索算法,公式表示为：f(n)=g(n)+h(n)，其中f(n)
是从初始点到目标点的估价函数，g(n)是从初始点到节点n的代价，h(n)是从节
点n到目标节点的估计代价，保证找到最短路径关键在于估价函数h(n)的选取。&lt;br/&gt;
一、几个相关知识：&lt;br/&gt;
&lt;strong&gt;启发式搜索&lt;/strong&gt;：启发式搜索就是在状态空间中的搜索对每一个搜索的位置进行评估，得到最好的位置，再从这个位置进行搜索直到目标。这样可以省略大量无畏的搜索路径，提到了效率。在启发式搜索中，对位置的估价是十分重要的。采用了不同的估价可以有不同的效果。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;估价函数&lt;/strong&gt;：从当前节点移动到目标节点的预估费用；这个估计就是启发式的。在寻路问题和迷宫问题中，我们通常用曼哈顿（manhattan）估价函数。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;em&gt;A&lt;/em&gt;算法的特点&lt;/em&gt;&lt;em&gt;：A&lt;/em&gt;算法在理论上是时间最优的，但是也有缺点：它的空间增长是指数级别的。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;em&gt;A&lt;/em&gt;算法与BFS&lt;/em&gt;&lt;em&gt;：可以这样说，BFS是A&lt;/em&gt;算法的一个特例。对于一个BFS算法，从当前节点扩展出来的每一个节点（如果没有被访问过的话）都要放进队列进行进一步扩展。也就是说BFS的估计函数h永远等于0，没有一点启发式的信息，可以认为BFS是“最烂的”A*算法。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;em&gt;IDA&lt;/em&gt;算法&lt;/em&gt;&lt;em&gt;：这种算法被称为迭代加深A&lt;/em&gt;算法，可以有效的解决A*空间增长带来的问题，甚至可以不用到优先级队列。&lt;/p&gt;

&lt;p&gt;二、A*伪代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    push startNode onto openList
    while(openList is not empty) {
        if current is goal return path

        remove currentNode from openList
        push currentNode onto closedList
        for each neighbor in negighbors {
            if neighbor is not in openList {
                save g, h, and f
                save current parent
                add neighbor to openList
            }
            
            if neighbor is in openList
                And g is better than previous g {
                save g and f
                save the current parent
            }
            
        }
    }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;三、coffeescript实现&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;astar =
    init: (grid) -&gt;
        for x in [0...grid.length]
            for y in [0...grid[x].length]
                grid[x][y].f = 0
                grid[x][y].g = 0
                grid[x][y].h = 0
                grid[x][y].debug = &quot;&quot;
                grid[x][y].parent = null
                
    search: (grid, start, end) -&gt;
        astar.init grid

        openList = []
        closeList = []
        openList.push start

        while openList.length &gt; 0

            # 获取最小的f(x)的点
            lowInd = 0
            for i in [0...openList.length]
                lowInd = i if openList[i].f &lt; openList[lowInd].f
            currentNode = openList[lowInd]

            # 到达目标点，返回路径
            if currentNode.pos is end.pos
                curr = currentNode
                ret = []
                while curr.parent
                    ret.push curr
                    curr = curr.parent
                return ret.reverse()

            # 最短路径搜索过程
            # 将当前点从openList移至closeList
            # 处理当前点的每个相邻点
            openList.removeGraphNode currentNode
            closeList.push currentNode
            neightbors = astar.neighbors grid, currentNode

            for i in [0...neighbors.length]
                neighbor = neighbor[i]
                if closeList.findGraphNode(neighbor) or neighbor.isWall()
                    # 无效点，跳至下一个相邻点
                    continue

                # gScore 是起始点到当前点所经过的距离
                # 需要判断当前相邻是否是最短距离
                gScore = currentNode.g + 1 # 1是当前点到相邻点的距离
                gScoreIsBest = false

                if !openList.findGraphNode(neighbor)
                    # 第一次到达当前点， 它必是当前最短距离
                    # 并且，需要计算 h(x) 
                    gScoreIsBest = true
                    neighbor.h = astar.heuristic neighbor.pos, end.pos
                    openList.push neighbor
                else if gScore &lt; neighbor.g
                    # 已经到达过该点，并且路径短于上次
                    gScoreIsBest = true

                if gScoreIsBest
                    # 找到当前的最短路径，将它保存起来
                    neighbor.parent = currentNode
                    neighbor.g = gScore
                    neighbor.f = neighbor.g + neighbor.h
                    neighbor.debug = &quot;F: &quot; + neighbor.f +
                        &quot;&lt;br/&gt;G: &quot; + neighbor.g + &quot;&lt;br/&gt;H:&quot; + neighbor.h

        # 未找到最短路径，返回空
        return []
        
    heuristic: (pos0, pos1) -&gt;
        return Math.abs(pos1.x - pos0.x) + Math.abs(pos1.y -pos0.y)
        
    neighbors: (grid, node) -&gt;
        ret = []
        x = node.pos.x
        y = node.pos.y

        ret.push grid[x-1][y] if grid[x-1]?[y]? 
        ret.push grid[x+1][y] if grid[x+1]?[y]? 
        ret.push grid[x][y-1] if grid[x]?[y-1]? 
        ret.push grid[x][y+1] if grid[x]?[y+1]? 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考：&lt;br/&gt;
&lt;a href=&quot;http://en.wikipedia.org/wiki/A*_search_algorithm#Algorithm_description&quot; &gt;A* search algorithm description on wiki&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;http://www.briangrinstead.com/blog/astar-search-algorithm-in-javascript&quot; &gt;astar-search-algorithm-in-javascript&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;http://qiao.github.io/PathFinding.js/visual/&quot; &gt;vistual PathFinding.js&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;http://www.cppblog.com/mythit/archive/2009/04/19/80492.aspx&quot; &gt;A*算法入门&lt;/a&gt;&lt;/p&gt;
</content> </entry><entry> <link type="text/html" rel="alternate" href="http://127.0.0.1:8000/blog/posts/Crawler.html"/> <title>Crawler</title> <published>2014-04-19 12:26:04</published> <updated>2014-04-19 12:26:04</updated> <author> <name>Jie</name> <uri>http://127.0.0.1:8000/blog</uri> </author> <content type="html">&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;portia&lt;/strong&gt;&lt;br/&gt;
  Visual scraping for Scrapy. &lt;a href=&quot;https://github.com/scrapinghub/portia&quot;&gt;https://github.com/scrapinghub/portia&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content> </entry><entry> <link type="text/html" rel="alternate" href="http://127.0.0.1:8000/blog/posts/Online-learning-webiste.html"/> <title>Online learning webiste</title> <published>2014-04-16 11:26:11</published> <updated>2014-04-16 11:26:11</updated> <author> <name>Jie</name> <uri>http://127.0.0.1:8000/blog</uri> </author> <content type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://learnlayout.com/&quot; &gt;Learning CSS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content> </entry> </feed>