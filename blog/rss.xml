<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"> <channel> <title>Jie&#039;s Blog</title> <link>http://127.0.0.1:8000/blog</link> <atom:link href="http://127.0.0.1:8000/blog/rss.xml" rel="self" type="application/rss+xml" /> <language>en-us</language> <pubDate>Wed, 04 Feb 2015 21:25:54 +0800</pubDate> <item> <title>VIM for Rails</title> <link>http://127.0.0.1:8000/blog/posts/VIM-for-Rails.html</link> <pubDate>2014-05-27 01:35:30</pubDate> <author>Jie</author> <guid isPermaLink="true">http://127.0.0.1:8000/blog/posts/VIM-for-Rails.html</guid> <category><![CDATA[ vim ]]></category><category><![CDATA[ rails ]]></category> <description><![CDATA[ <p>使用vim来进行Rails开发，对配置过程略做记录，前提vim已安装完毕。<br/>
1、 <strong>安装pathogen</strong><br/>
pathogens是vim的插件管理工具，可简化对vim插件的管理。<br/>
安装如下：</p>

<pre><code>mkdir -p ~/.vim/autoload ~/.vim/bundle; \
curl -LSso ~/.vim/autoload/pathogen.vim \
    https://raw.github.com/tpope/vim-pathogen/master/autoload/pathogen.vim;</code></pre>

<p>然后在<code>.vimrc</code>中加入：</p>

<pre><code>execute pathogen#infect()
" 加在下列配置之前
syntax on
filetype plugin indent on</code></pre>

<p>2、 <strong>rails.vim</strong><br/>
rails插件，无需多介绍。<br/>
常用快捷键:</p>

<pre><code>gf           =>  跳转到定义
ctrl+6       =>  返回上一文件
</code></pre>

<p>常用命令：</p>

<pre><code>
# 查找文件
:Rfind routes.rb

# 打开model
:Rmodel user

# 打开controller
:Rcontroller users
:Rcont users

# 打开view
:Rview user/index
:Rview user/_user

# 启动server
:Rserver
# 关闭server
:Rserver! -

# 打开js文件
:Rjavascript js_name</code></pre>

<p><strong>注</strong>:其<code>Rtag</code>命令使用的是<code>exuberant-ctags</code>中的<code>ctags</code>，安装Emacs后也会安装一个<code>ctag</code>工具，会与之冲突，可以将Emacs的<code>ctags</code>重命名后安装<code>exuberant-ctags</code>解决之。</p>

<p>3、 <strong>nerdtree</strong><br/>
显示目录树，命令<code>:NERDTree</code>显示目录。   </p>

<p>4、 <strong>vim-surround</strong><br/>
方便输入括号等的插件，使用<code>ctrl+g s =</code>，即可插入<code>&lt;%=  %&gt;</code>。   </p>

<p>5、 <strong>sparkup</strong><br/>
html编写插件，输入<code>div#header</code>，然后按<code>ctrl+e</code>，就会扩展为
<code>&lt;div id=&quot;header&quot;&gt;&lt;/div&gt;</code>。</p>

<p>6、 <strong>snipmate</strong><br/>
代码片段补全</p>

<p>7、 <strong>neocomplcache</strong><br/>
代码补全提示</p>

<p>8、 <strong>auto-pairs</strong><br/>
括号自动补全</p>
 ]]></description> </item><item> <title>Metaprogramming(code generator)</title> <link>http://127.0.0.1:8000/blog/posts/Metaprogrammingcode-generator.html</link> <pubDate>2014-05-03 19:23:53</pubDate> <author>Jie</author> <guid isPermaLink="true">http://127.0.0.1:8000/blog/posts/Metaprogrammingcode-generator.html</guid> <category><![CDATA[ ruby ]]></category><category><![CDATA[ mindmap ]]></category> <description><![CDATA[ <p>根本没有什么元编程，只有编程！？
<br>
{% img /static/img/CodeWriter.png %}
<br></p>

<ul>
<li><p>注1: 由于代码字符串和块非常相似，因此，在很多情况下，可以选择使用任
  意一种。但是，一般情况下，只要能用块就尽量用块。</p></li>
<li><p>注2: 使一个模块可以通过钩子方法扩展它的包含者。</p></li>
</ul>

<pre><code>module M
  def self.included(base)
    base.extend(ClassMethods)
  end

  module ClassMethods
    def my_method
      'a class method'
    end
  end
end

class C
  include M
end

C.my_method   # =>  "a class method"</code></pre>
 ]]></description> </item><item> <title>Meta programming(Class)</title> <link>http://127.0.0.1:8000/blog/posts/Meta-programmingClass.html</link> <pubDate>2014-05-03 17:51:04</pubDate> <author>Jie</author> <guid isPermaLink="true">http://127.0.0.1:8000/blog/posts/Meta-programmingClass.html</guid> <category><![CDATA[ ruby ]]></category><category><![CDATA[ mindmap ]]></category> <description><![CDATA[ <p>在Ruby中，使用class定义类时，实际上是在运行代码，这与java之类的静态语
言有很大的差别。<br/>
另外，类只是一个增强的模块，因此，任何适用于类的东西也
适用于模块。
<br>
{% img /static/img/ObjectDefinitions.png %}
<br>
 * 注1:在类(或模块)定义时，类本身充当了当前对象self的角色。</p>

<pre><code>result = class MyClass
  self
end

result     # =>  MyClass</code></pre>

<ul>
<li><p>注2:Ruby中总是存在一个当前对象self，与此类似，也总是存在一个当前类
   （或模块）。每当通过class关键字来打开一个类时，这个类就成为当前类，
   但是使用class关键字需要一个类的名字。
   如果只有一个类的引用，需要用class_eval()方法打开这个类。</p></li>
<li><p>注3：类实例变量仅仅是属于Class类对象的普通实例变量。它仅仅可以被类
   本身所访问，而不能被类的实例或之类所访问。</p></li>
<li><p>注4：类方法的实质，它们只是一个类的单件方法。</p></li>
<li><p>注5: 在类定义中使用一个类方法。</p></li>
<li><p>注6: eigenclass是一个对象特有的隐藏类，它是单件方法存在的地方。Ruby中可以使用如下语法进入eigenclass的作用域。</p></li>
</ul>

<pre><code>class << an_object 
  # do something
end</code></pre>

<ul>
<li><p>注7: 如果对象是eigenclass，那么Ruby不是从它所在的类开始，而是从这个
   eigenclass类中开始查找方法，如图。
   <br>
   {% img /static/img/eigenclassMethod.png %}</p></li>
<li><p>注8: 一个对象的eigenclass的超类是这个对象的类，一个类的eigenclass的
   超类是这个类的超类的eigenclass,如图。
   {% img /static/img/eigenclassInherit.png %}</p></li>
<li><p>注9: 通过向类的eigenclass中混入模块来定义类方法。</p></li>
<li><p>注10: 通过给一个对象的eigenclass混入模块来定义单件方法。</p></li>
<li><p>注11: 1. 给方法定义一个别名；2.重新定义这个方法；3.在新的方法中调用老的方法。</p></li>
<li><p>注12: 1.环绕别名是一种猴子补丁，可能会破坏已有代码。2.你永远不该把一个环绕别名加载两次。</p></li>
</ul>
 ]]></description> </item><item> <title>Metaprogramming(Block)</title> <link>http://127.0.0.1:8000/blog/posts/MetaprogrammingBlock.html</link> <pubDate>2014-05-03 17:06:28</pubDate> <author>Jie</author> <guid isPermaLink="true">http://127.0.0.1:8000/blog/posts/MetaprogrammingBlock.html</guid> <category><![CDATA[ ruby ]]></category><category><![CDATA[ mindmap ]]></category> <description><![CDATA[ <p>块继承自“函数式编程语言(functional programming languages)”的世界。
<br>
{% img /static/img/blocks.png %}
<br>
* 注1: 在一个方法中，可以向Ruby询问当前的方法调用是否包含块。这可以通
  过Kernel#block_given?()方法来做到。</p>

<ul>
<li><p>注2: 如果在一个扁平作用域中定义了多个方法，这这些方法可以用一个作用
  域们进行保护，并共享绑定，这种技术称为共享作用域。</p></li>
<li><p>注3: 传递给instance_eval()方法的块称为一个上下文探针，因为它就像是一
  个深入到对象中的代码片段，对其操作。</p></li>
</ul>

<pre><code>class C
  def initialize
    @x="a private instance variable"
  end
end

obj=C.new
obj.instance_eval(@x) #=>"a private instance variable"</code></pre>

<ul>
<li>注4: 有时，你会创建一个对象，仅仅是为了在其中执行块。这样的对象称为洁净室。洁净室仅仅是一个用来执行块的环境，它通常还会暴露若干有用的方法供块调用。</li>
</ul>

<pre><code>class CleanRoom
  def a_useful_method(x);x*2;end
end

CleanRoom.new.instance_eval{a_useful_method(3)}  #=>6</code></pre>

<ul>
<li><p>注5: 1.return方式不同。lambda从可调用对象中返回，而proc从原始上下文中返回。
2.参数检查方式不同。如果lambda的产生数量不对，这它会失败，同时抛出一个
ArgumentError错误；而proc则会自动调整传递进来的参数，通过忽略多余的参
数以及为未赋值参数置nil。</p></li>
<li><p>注6: Method对象类似于lambda，但是有一个重要的区别：lambda在它的作用域中执行(它是一个闭包)，而Method对象会在它自身所在对象的作用域中执行。</p></li>
</ul>
 ]]></description> </item><item> <title>Metaprogramming(Methods)</title> <link>http://127.0.0.1:8000/blog/posts/MetaprogrammingMethods.html</link> <pubDate>2014-05-03 16:44:19</pubDate> <author>Jie</author> <guid isPermaLink="true">http://127.0.0.1:8000/blog/posts/MetaprogrammingMethods.html</guid> <category><![CDATA[ ruby ]]></category><category><![CDATA[ mindmap ]]></category> <description><![CDATA[ <p>Ruby是动态语言，没有静态类型检查，同时也提供了很多java等静态语言无法提
供的编程技巧。本章主要专注于消除重复代码的技巧，通过用两种不同的方式对一
段代码的重构来展示Ruby的强大功能，涉及的知识点比较少。
<br>
{% img /static/img/methods.png %}
<br>
* 注1: method_missing()是Kernel中的一个实例方法，当Ruby找不到调用的方
  法时，它最后就会调用这个名为method_missing()的方法。</p>

<ul>
<li>注2: 移除一个对象中的所有方法，以便把它们转换成幽灵方法。</li>
</ul>

<p>-------------------------------------------------------------------------------
<strong>重构例子</strong></p>

<pre><code>class Computer
  def initialize(computer_id, data_source)
    @id = computer_id
    @data_source = data_source
  end
  def mouse
    info = @data_source.get_mouse_info(@id)
    price = @data_source.get_mouse_price(@id)
    result = "Mouse: #{info} ($#{price})"
    return "* #{result}" if price >= 100
    result
  end
  def cpu
    info = @data_source.get_cpu_info(@id)
    price = @data_source.get_cpu_price(@id)
    result = "Cpu: #{info} ($#{price})"
    return "* #{result}" if price >= 100
    result
  end
  def keyboard
    info = @data_source.get_keyboard_info(@id)
    price = @data_source.get_keyboard_price(@id)
    result = "Keyboard: #{info} ($#{price})"
    return "* #{result}" if price >= 100
    result
  end
  # ...
end</code></pre>

<pre><code>class Computer
  def initialize(computer_id, data_source)
    @id = computer_id
    @data_source = data_source
    # 使用内省方式提取所有组件的名字
    data_source.methods.grep(/^get_(.*)_info$/) { Computer.define_component $1 }
  end

  def self.define_component(name)
    # 使用define_method()动态定义方法
    define_method(name) do
      # 使用send()方法集中处理
      info = @data_source.send "get_#{name}_info", @id
      price = @data_source.send "get_#{name}_price", @id
      result = "#{name.capitalize}: #{info} ($#{price})"
      return "* #{result}" if price >= 100
      result
    end
  end
  
  define_component :mouse
  define_component :cpu
  define_component :keyboard
end</code></pre>

<pre><code>class Computer
  # 创建白板， 以免方法命名冲突
  instance_methods.each do |m|
    undef_method m unless m.to_s =~ /^__|method_missing|respond_to?/
  end

  def initialize(computer_id, data_source)
    @id = computer_id
    @data_source = data_source
  end

  # 在method_missing()中创建方法
  def method_missing(name, *args)
    super if !respond_to?(name)
    info = @data_source.send("get_#{name}_info", @id)
    price = @data_source.send("get_#{name}_price", @id)
    result = "#{name.to_s.capitalize}: #{info} ($#{price})"
    return "* #{result}" if price >= 100
    result
  end

  # 覆写respond_to?()，保证查询方法时返回正确结果
  def respond_to?(method)
    @data_source.respond_to?("get_#{method}_info") || super
  end
end</code></pre>
 ]]></description> </item><item> <title>Metaprogramming(ObjectModel)</title> <link>http://127.0.0.1:8000/blog/posts/MetaprogrammingObjectModel.html</link> <pubDate>2014-05-02 20:44:57</pubDate> <author>Jie</author> <guid isPermaLink="true">http://127.0.0.1:8000/blog/posts/MetaprogrammingObjectModel.html</guid> <category><![CDATA[ ruby ]]></category><category><![CDATA[ mindmap ]]></category> <description><![CDATA[ <p>在Ruby程序中，除了对象之外，还有类、模块以及实例变量这些语言构件。这
些语言构件存在于其中的系统称为<strong>对象模型</strong>。在对象模型中，你可以找到诸
如&quot;这个方法来自哪个类&quot;和&quot;当我包含这个模块是会发生什么&quot;此类问题的答案。
<br>
{% img /static/img/ObjectModel.png %}
<br>
* 注1: class关键字更像是一个作用域操作符而不是类型声明语句，它的确可以
  创建一个还不存在的类，不过也可以把这看成是一个副作用。对于class关键
  字，其核心任务是把你带到类的上下文中，让你可以在其中定义方法。</p>

<ul>
<li><p>注2: 修改已有类的特性时，由于粗心导致bug，像这种鲁莽的修改方式被称为
  猴子补丁。不过，如果是正确的运行打开类这种技术，猴子补丁也可以表示为
  一个褒义词，会很有用。</p></li>
<li><p>注3: 对象是一组实例变量外加一个指向其类的引用。对象的方法并不存在于对象本身，而是存在于对象的类中。在类中，这些方法被称为类的实例方法。
类是一个对象（Class类的一个实例）外加一组实例方法和一个对其超类的引用。
值得注意的是，实例变量存放在对象中，而方法存放在类中，比如</p></li>
</ul>

<pre><code>class MyClass
  def my_method
    @v = 1
  end
end

obj = MyClass.new
obj.class              # => MyClass</code></pre>

<p>上面代码结构可表示为：
{% img /static/img/ObjectClass.png %}</p>

<ul>
<li><p>注4: 一个类只不过是一个增强的Module，它只是在Module基础上增加了三个
  方法——new()、allocate()和superclass()而已，结构如下。
  {% img /static/img/ModuleClass.png %}</p></li>
<li><p>注5: 每个类都有一个祖先链，这个链从自己所属的类开始，向上直到BasicObject结束。其中，Object类包含了Kernel模块，故Kernel方法对所有对象可用。</p></li>
</ul>
 ]]></description> </item><item> <title>Metaprogramming(Tutorial)</title> <link>http://127.0.0.1:8000/blog/posts/MetaprogrammingTutorial.html</link> <pubDate>2014-04-29 21:56:38</pubDate> <author>Jie</author> <guid isPermaLink="true">http://127.0.0.1:8000/blog/posts/MetaprogrammingTutorial.html</guid> <category><![CDATA[ ruby ]]></category><category><![CDATA[ mindmap ]]></category> <description><![CDATA[ <p>元编程(Metaprogramming)，简单来说，就是写出编写代码的代码。正式的定义为：编写在运行时操纵语言构件的代码。
Ruby是一门对元编程支持很强大的语言(只是比lisp弱一点)，而且，元编程
也是通向Ruby的高级编程之路。可以说，除非掌握了元编程否则不能算是真正掌
握了Ruby。
下图简要总结了&lt;Ruby元编程&gt;的基本内容，经验有限，不足之处请多指正。
<br>
{% img /static/img/RubyMetaprogramming.png %}
<br> 
就如蜘蛛侠大叔曾经说的，能力越大，责任越大。元编程赋予了你强大的能力，同时也意味着你需要肩负更大的责任。</p>
 ]]></description> </item><item> <title>A* Algorithm</title> <link>http://127.0.0.1:8000/blog/posts/A-Algorithm.html</link> <pubDate>2014-04-22 18:10:18</pubDate> <author>Jie</author> <guid isPermaLink="true">http://127.0.0.1:8000/blog/posts/A-Algorithm.html</guid> <category><![CDATA[ algorithm ]]></category><category><![CDATA[ a* ]]></category> <description><![CDATA[ <p>A*算法是一种经典的启发式搜索算法,公式表示为：f(n)=g(n)+h(n)，其中f(n)
是从初始点到目标点的估价函数，g(n)是从初始点到节点n的代价，h(n)是从节
点n到目标节点的估计代价，保证找到最短路径关键在于估价函数h(n)的选取。<br/>
一、几个相关知识：<br/>
<strong>启发式搜索</strong>：启发式搜索就是在状态空间中的搜索对每一个搜索的位置进行评估，得到最好的位置，再从这个位置进行搜索直到目标。这样可以省略大量无畏的搜索路径，提到了效率。在启发式搜索中，对位置的估价是十分重要的。采用了不同的估价可以有不同的效果。</p>

<p><strong>估价函数</strong>：从当前节点移动到目标节点的预估费用；这个估计就是启发式的。在寻路问题和迷宫问题中，我们通常用曼哈顿（manhattan）估价函数。</p>

<p><em><em>A</em>算法的特点</em><em>：A</em>算法在理论上是时间最优的，但是也有缺点：它的空间增长是指数级别的。</p>

<p><em><em>A</em>算法与BFS</em><em>：可以这样说，BFS是A</em>算法的一个特例。对于一个BFS算法，从当前节点扩展出来的每一个节点（如果没有被访问过的话）都要放进队列进行进一步扩展。也就是说BFS的估计函数h永远等于0，没有一点启发式的信息，可以认为BFS是“最烂的”A*算法。</p>

<p><em><em>IDA</em>算法</em><em>：这种算法被称为迭代加深A</em>算法，可以有效的解决A*空间增长带来的问题，甚至可以不用到优先级队列。</p>

<p>二、A*伪代码</p>

<pre><code>    push startNode onto openList
    while(openList is not empty) {
        if current is goal return path

        remove currentNode from openList
        push currentNode onto closedList
        for each neighbor in negighbors {
            if neighbor is not in openList {
                save g, h, and f
                save current parent
                add neighbor to openList
            }
            
            if neighbor is in openList
                And g is better than previous g {
                save g and f
                save the current parent
            }
            
        }
    }</code></pre>

<p>三、coffeescript实现</p>

<pre><code>astar =
    init: (grid) ->
        for x in [0...grid.length]
            for y in [0...grid[x].length]
                grid[x][y].f = 0
                grid[x][y].g = 0
                grid[x][y].h = 0
                grid[x][y].debug = ""
                grid[x][y].parent = null
                
    search: (grid, start, end) ->
        astar.init grid

        openList = []
        closeList = []
        openList.push start

        while openList.length > 0

            # 获取最小的f(x)的点
            lowInd = 0
            for i in [0...openList.length]
                lowInd = i if openList[i].f < openList[lowInd].f
            currentNode = openList[lowInd]

            # 到达目标点，返回路径
            if currentNode.pos is end.pos
                curr = currentNode
                ret = []
                while curr.parent
                    ret.push curr
                    curr = curr.parent
                return ret.reverse()

            # 最短路径搜索过程
            # 将当前点从openList移至closeList
            # 处理当前点的每个相邻点
            openList.removeGraphNode currentNode
            closeList.push currentNode
            neightbors = astar.neighbors grid, currentNode

            for i in [0...neighbors.length]
                neighbor = neighbor[i]
                if closeList.findGraphNode(neighbor) or neighbor.isWall()
                    # 无效点，跳至下一个相邻点
                    continue

                # gScore 是起始点到当前点所经过的距离
                # 需要判断当前相邻是否是最短距离
                gScore = currentNode.g + 1 # 1是当前点到相邻点的距离
                gScoreIsBest = false

                if !openList.findGraphNode(neighbor)
                    # 第一次到达当前点， 它必是当前最短距离
                    # 并且，需要计算 h(x) 
                    gScoreIsBest = true
                    neighbor.h = astar.heuristic neighbor.pos, end.pos
                    openList.push neighbor
                else if gScore < neighbor.g
                    # 已经到达过该点，并且路径短于上次
                    gScoreIsBest = true

                if gScoreIsBest
                    # 找到当前的最短路径，将它保存起来
                    neighbor.parent = currentNode
                    neighbor.g = gScore
                    neighbor.f = neighbor.g + neighbor.h
                    neighbor.debug = "F: " + neighbor.f +
                        "<br/>G: " + neighbor.g + "<br/>H:" + neighbor.h

        # 未找到最短路径，返回空
        return []
        
    heuristic: (pos0, pos1) ->
        return Math.abs(pos1.x - pos0.x) + Math.abs(pos1.y -pos0.y)
        
    neighbors: (grid, node) ->
        ret = []
        x = node.pos.x
        y = node.pos.y

        ret.push grid[x-1][y] if grid[x-1]?[y]? 
        ret.push grid[x+1][y] if grid[x+1]?[y]? 
        ret.push grid[x][y-1] if grid[x]?[y-1]? 
        ret.push grid[x][y+1] if grid[x]?[y+1]? 
</code></pre>

<p>参考：<br/>
<a href="http://en.wikipedia.org/wiki/A*_search_algorithm#Algorithm_description" >A* search algorithm description on wiki</a><br/>
<a href="http://www.briangrinstead.com/blog/astar-search-algorithm-in-javascript" >astar-search-algorithm-in-javascript</a><br/>
<a href="http://qiao.github.io/PathFinding.js/visual/" >vistual PathFinding.js</a><br/>
<a href="http://www.cppblog.com/mythit/archive/2009/04/19/80492.aspx" >A*算法入门</a></p>
 ]]></description> </item><item> <title>Crawler</title> <link>http://127.0.0.1:8000/blog/posts/Crawler.html</link> <pubDate>2014-04-19 12:26:04</pubDate> <author>Jie</author> <guid isPermaLink="true">http://127.0.0.1:8000/blog/posts/Crawler.html</guid> <category><![CDATA[ tools ]]></category> <description><![CDATA[ <ul>
<li><strong>portia</strong><br/>
  Visual scraping for Scrapy. https://github.com/scrapinghub/portia</li>
</ul>
 ]]></description> </item><item> <title>Online learning webiste</title> <link>http://127.0.0.1:8000/blog/posts/Online-learning-webiste.html</link> <pubDate>2014-04-16 11:26:11</pubDate> <author>Jie</author> <guid isPermaLink="true">http://127.0.0.1:8000/blog/posts/Online-learning-webiste.html</guid> <category><![CDATA[ website ]]></category><category><![CDATA[ learning ]]></category> <description><![CDATA[ <ul>
<li><a href="http://learnlayout.com/" >Learning CSS</a></li>
</ul>
 ]]></description> </item> </channel> </rss>